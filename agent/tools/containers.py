"""Container lifecycle tools — wraps extra-container and nixos-container CLI.

These tools are registered with the PydanticAI agent and called when the
agent needs to create, destroy, start, or stop NixOS containers.

All CLI invocations go through run_command() from agent.tools.cli.
The Nix expression for container creation is generated by agent.nix_gen.generator.

Observability: every lifecycle operation is wrapped in a logfire.span() so that
container create/destroy/start/stop appear as discrete spans in traces, nested
under the parent PydanticAI agent run. On failure, the span captures stderr
for quick diagnosis without digging through journalctl.
"""

from __future__ import annotations

import logging
import tempfile
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING

import logfire

from agent.nix_gen.generator import generate_container_expr
from agent.tools.cli import run_command

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from agent.nix_gen.models import ContainerSpec


@dataclass
class ContainerResult:
    """Structured result from a container lifecycle operation.

    Returned by all container tools — the agent uses this to
    compose a response for the user.
    """

    success: bool
    name: str
    message: str
    error: str | None = field(default=None)


async def create_container(
    spec: ContainerSpec,
    flake_path: str | None = None,
) -> ContainerResult:
    """Create and start a NixOS container from a ContainerSpec.

    Flow:
        1. Generate a Nix expression from the spec via generate_container_expr
        2. Write the expression to a temporary .nix file
        3. Pass the file to `extra-container create --start`
        4. Clean up the temp file
        5. Return a structured result

    Args:
        spec: Validated container specification (name, owner, modules).
        flake_path: Path to the voxnix flake root. Falls back to
            VOXNIX_FLAKE_PATH env var if not provided.

    Returns:
        ContainerResult indicating success or failure with details.
    """
    with logfire.span(
        "container.create",
        container_name=spec.name,
        owner=spec.owner,
        modules=spec.modules,
    ):
        expr = generate_container_expr(spec, flake_path)

        with tempfile.NamedTemporaryFile(
            suffix=".nix",
            prefix=f"voxnix-{spec.name}-",
            mode="w",
            delete=False,
        ) as tmp:
            tmp.write(expr)
            tmp_path = tmp.name

        try:
            result = await run_command(
                "extra-container",
                "create",
                tmp_path,
                "--start",
                # Container creation builds the full NixOS closure — on a cold
                # store this can take several minutes downloading packages.
                # 600s (10 min) gives headroom for first-time builds.
                timeout_seconds=600,
            )
        finally:
            Path(tmp_path).unlink(missing_ok=True)

        if result.success:
            logfire.info(
                "Container '{container_name}' created and started",
                container_name=spec.name,
            )
            return ContainerResult(
                success=True,
                name=spec.name,
                message=f"Container '{spec.name}' created and started.",
            )

        logfire.error(
            "Failed to create container '{container_name}'",
            container_name=spec.name,
            stderr=result.stderr,
            stdout=result.stdout,
            returncode=result.returncode,
        )
        logger.error(
            "create_container failed: name=%s returncode=%d stderr=%r stdout=%r",
            spec.name,
            result.returncode,
            result.stderr,
            result.stdout,
        )
        return ContainerResult(
            success=False,
            name=spec.name,
            message=f"Failed to create container '{spec.name}'.",
            error=result.stderr or result.stdout,
        )


async def destroy_container(name: str) -> ContainerResult:
    """Destroy a NixOS container and its filesystem.

    Wraps `nixos-container destroy <name>`. This is a destructive
    operation — the container's ephemeral state is lost. Persistent
    data on ZFS bind mounts is unaffected (ZFS dataset lifecycle is
    managed separately via create_zfs_dataset / destroy_zfs_dataset).

    Args:
        name: Container name (must match the running container's machine name).

    Returns:
        ContainerResult indicating success or failure.
    """
    with logfire.span("container.destroy", container_name=name):
        result = await run_command("nixos-container", "destroy", name)

        if result.success:
            logfire.info("Container '{container_name}' destroyed", container_name=name)
            return ContainerResult(
                success=True,
                name=name,
                message=f"Container '{name}' destroyed.",
            )

        logfire.error(
            "Failed to destroy container '{container_name}'",
            container_name=name,
            stderr=result.stderr,
            stdout=result.stdout,
            returncode=result.returncode,
        )
        return ContainerResult(
            success=False,
            name=name,
            message=f"Failed to destroy container '{name}'.",
            error=result.stderr or result.stdout,
        )


async def start_container(name: str) -> ContainerResult:
    """Start a stopped NixOS container.

    Wraps `nixos-container start <name>`.

    Args:
        name: Container name.

    Returns:
        ContainerResult indicating success or failure.
    """
    with logfire.span("container.start", container_name=name):
        result = await run_command("nixos-container", "start", name)

        if result.success:
            logfire.info("Container '{container_name}' started", container_name=name)
            return ContainerResult(
                success=True,
                name=name,
                message=f"Container '{name}' started.",
            )

        logfire.error(
            "Failed to start container '{container_name}'",
            container_name=name,
            stderr=result.stderr,
            stdout=result.stdout,
            returncode=result.returncode,
        )
        return ContainerResult(
            success=False,
            name=name,
            message=f"Failed to start container '{name}'.",
            error=result.stderr or result.stdout,
        )


async def stop_container(name: str) -> ContainerResult:
    """Stop a running NixOS container.

    Wraps `nixos-container stop <name>`.

    Args:
        name: Container name.

    Returns:
        ContainerResult indicating success or failure.
    """
    with logfire.span("container.stop", container_name=name):
        result = await run_command("nixos-container", "stop", name)

        if result.success:
            logfire.info("Container '{container_name}' stopped", container_name=name)
            return ContainerResult(
                success=True,
                name=name,
                message=f"Container '{name}' stopped.",
            )

        logfire.error(
            "Failed to stop container '{container_name}'",
            container_name=name,
            stderr=result.stderr,
            stdout=result.stdout,
            returncode=result.returncode,
        )
        return ContainerResult(
            success=False,
            name=name,
            message=f"Failed to stop container '{name}'.",
            error=result.stderr or result.stdout,
        )
