"""Container lifecycle tools — wraps extra-container and nixos-container CLI.

These tools are registered with the PydanticAI agent and called when the
agent needs to create, destroy, start, or stop NixOS containers.

All CLI invocations go through run_command() from agent.tools.cli.
The Nix expression for container creation is generated by agent.nix_gen.generator.
ZFS dataset provisioning is handled by agent.tools.zfs — create_container
provisions the workspace dataset before building the container, and
destroy_container cleans it up after tearing the container down.

Observability: every lifecycle operation is wrapped in a logfire.span() so that
container create/destroy/start/stop appear as discrete spans in traces, nested
under the parent PydanticAI agent run. On failure, the span captures stderr
for quick diagnosis without digging through journalctl.
"""

from __future__ import annotations

import logging
import tempfile
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING

import logfire

from agent.nix_gen.generator import generate_container_expr
from agent.tools.cli import run_command
from agent.tools.zfs import create_container_dataset, destroy_container_dataset

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from agent.nix_gen.models import ContainerSpec


@dataclass
class ContainerResult:
    """Structured result from a container lifecycle operation.

    Returned by all container tools — the agent uses this to
    compose a response for the user.
    """

    success: bool
    name: str
    message: str
    error: str | None = field(default=None)


async def create_container(
    spec: ContainerSpec,
    flake_path: str | None = None,
) -> ContainerResult:
    """Create and start a NixOS container from a ContainerSpec.

    Flow:
        1. Provision a ZFS dataset for the container's persistent workspace
        2. Generate a Nix expression from the spec via generate_container_expr
        3. Write the expression to a temporary .nix file
        4. Pass the file to `extra-container create --start`
        5. Clean up the temp file
        6. Return a structured result

    If ZFS dataset creation succeeds but container creation fails, the
    orphaned dataset is cleaned up automatically.

    Args:
        spec: Validated container specification (name, owner, modules).
        flake_path: Path to the voxnix flake root. Falls back to
            VOXNIX_FLAKE_PATH env var if not provided.

    Returns:
        ContainerResult indicating success or failure with details.
    """
    with logfire.span(
        "container.create",
        container_name=spec.name,
        owner=spec.owner,
        modules=spec.modules,
    ):
        # ── Step 1: Provision ZFS dataset for persistent workspace ─────
        zfs_result = await create_container_dataset(spec.owner, spec.name)
        if not zfs_result.success:
            logfire.error(
                "ZFS dataset creation failed for container '{container_name}'",
                container_name=spec.name,
                error=zfs_result.error,
            )
            logger.error(
                "create_container aborted: ZFS dataset creation failed for %s: %s",
                spec.name,
                zfs_result.error,
            )
            return ContainerResult(
                success=False,
                name=spec.name,
                message=f"Failed to provision storage for container '{spec.name}'.",
                error=zfs_result.error,
            )

        # Attach the workspace mount path to the spec so the Nix expression
        # generator includes a bindMounts entry in mkContainer.
        spec.workspace_path = zfs_result.mount_path

        # ── Step 2: Generate Nix expression and create container ───────
        expr = generate_container_expr(spec, flake_path)

        with tempfile.NamedTemporaryFile(
            suffix=".nix",
            prefix=f"voxnix-{spec.name}-",
            mode="w",
            delete=False,
        ) as tmp:
            tmp.write(expr)
            tmp_path = tmp.name

        try:
            result = await run_command(
                "extra-container",
                "create",
                tmp_path,
                "--start",
                # Container creation builds the full NixOS closure — on a cold
                # store this can take several minutes downloading packages.
                # 600s (10 min) gives headroom for first-time builds.
                timeout_seconds=600,
            )
        finally:
            Path(tmp_path).unlink(missing_ok=True)

        if result.success:
            logfire.info(
                "Container '{container_name}' created and started",
                container_name=spec.name,
            )
            return ContainerResult(
                success=True,
                name=spec.name,
                message=f"Container '{spec.name}' created and started.",
            )

        # ── Container creation failed ──────────────────────────────────────
        # Only clean up the ZFS dataset if the container was never installed.
        # extra-container prints "Installing containers:\n<name>" to stdout on
        # successful install before calling `systemctl start`. If the install
        # succeeded but the start failed, the container conf is in
        # /etc/nixos-containers/ and needs the workspace dataset to exist —
        # destroying it here would make the container unbootable.
        install_succeeded = "Installing containers:" in (result.stdout or "")
        if not install_succeeded:
            logfire.warning(
                "Container build/install failed for '{container_name}', cleaning up ZFS dataset",
                container_name=spec.name,
            )
            cleanup = await destroy_container_dataset(spec.owner, spec.name)
            if not cleanup.success:
                logger.error(
                    "Failed to clean up orphaned ZFS dataset for %s: %s",
                    spec.name,
                    cleanup.error,
                )
        else:
            logfire.warning(
                "Container '{container_name}' installed but failed to start — "
                "preserving ZFS dataset so container can be started manually",
                container_name=spec.name,
            )

        logfire.error(
            "Failed to create container '{container_name}'",
            container_name=spec.name,
            stderr=result.stderr,
            stdout=result.stdout,
            returncode=result.returncode,
        )
        logger.error(
            "create_container failed: name=%s returncode=%d stderr=%r stdout=%r",
            spec.name,
            result.returncode,
            result.stderr,
            result.stdout,
        )
        return ContainerResult(
            success=False,
            name=spec.name,
            message=f"Failed to create container '{spec.name}'.",
            error=result.stderr or result.stdout,
        )


async def destroy_container(name: str, owner: str | None = None) -> ContainerResult:
    """Destroy a NixOS container and its ZFS dataset.

    Wraps `extra-container destroy <name>`, then cleans up the container's
    ZFS dataset hierarchy if an owner is provided.

    Note: `nixos-container destroy` is intentionally NOT used here.
    After a `nixos-rebuild switch`, NixOS activation adopts any conf
    file present in /etc/nixos-containers/ into the system profile,
    causing `nixos-container destroy` to refuse with "cannot destroy
    declarative container". `extra-container destroy` handles cleanup
    correctly for containers created with `extra-container create`.

    Args:
        name: Container name (must match the running container's machine name).
        owner: Owner chat_id. When provided, the container's ZFS dataset
            (tank/users/<owner>/containers/<name>) is destroyed after the
            container itself. When None, only the container is destroyed
            (ZFS dataset is left intact — useful for debugging).

    Returns:
        ContainerResult indicating success or failure.
    """
    with logfire.span("container.destroy", container_name=name, owner=owner):
        result = await run_command("extra-container", "destroy", name)

        if result.success:
            logfire.info("Container '{container_name}' destroyed", container_name=name)

            # Clean up the ZFS dataset if owner is known.
            if owner:
                zfs_result = await destroy_container_dataset(owner, name)
                if not zfs_result.success:
                    logger.error(
                        "Container destroyed but ZFS cleanup failed for %s: %s",
                        name,
                        zfs_result.error,
                    )
                    return ContainerResult(
                        success=True,
                        name=name,
                        message=(
                            f"Container '{name}' destroyed, "
                            f"but storage cleanup failed: {zfs_result.error}"
                        ),
                    )

            return ContainerResult(
                success=True,
                name=name,
                message=f"Container '{name}' destroyed.",
            )

        logfire.error(
            "Failed to destroy container '{container_name}'",
            container_name=name,
            stderr=result.stderr,
            stdout=result.stdout,
            returncode=result.returncode,
        )
        logger.error(
            "destroy_container failed: name=%s returncode=%d stderr=%r stdout=%r",
            name,
            result.returncode,
            result.stderr,
            result.stdout,
        )
        return ContainerResult(
            success=False,
            name=name,
            message=f"Failed to destroy container '{name}'.",
            error=result.stderr or result.stdout,
        )


async def start_container(name: str) -> ContainerResult:
    """Start a stopped NixOS container.

    Wraps `nixos-container start <name>`.

    Args:
        name: Container name.

    Returns:
        ContainerResult indicating success or failure.
    """
    with logfire.span("container.start", container_name=name):
        result = await run_command("nixos-container", "start", name)

        if result.success:
            logfire.info("Container '{container_name}' started", container_name=name)
            return ContainerResult(
                success=True,
                name=name,
                message=f"Container '{name}' started.",
            )

        logfire.error(
            "Failed to start container '{container_name}'",
            container_name=name,
            stderr=result.stderr,
            stdout=result.stdout,
            returncode=result.returncode,
        )
        logger.error(
            "start_container failed: name=%s returncode=%d stderr=%r stdout=%r",
            name,
            result.returncode,
            result.stderr,
            result.stdout,
        )
        return ContainerResult(
            success=False,
            name=name,
            message=f"Failed to start container '{name}'.",
            error=result.stderr or result.stdout,
        )


async def stop_container(name: str) -> ContainerResult:
    """Stop a running NixOS container.

    Wraps `nixos-container stop <name>`.

    Args:
        name: Container name.

    Returns:
        ContainerResult indicating success or failure.
    """
    with logfire.span("container.stop", container_name=name):
        result = await run_command("nixos-container", "stop", name)

        if result.success:
            logfire.info("Container '{container_name}' stopped", container_name=name)
            return ContainerResult(
                success=True,
                name=name,
                message=f"Container '{name}' stopped.",
            )

        logfire.error(
            "Failed to stop container '{container_name}'",
            container_name=name,
            stderr=result.stderr,
            stdout=result.stdout,
            returncode=result.returncode,
        )
        logger.error(
            "stop_container failed: name=%s returncode=%d stderr=%r stdout=%r",
            name,
            result.returncode,
            result.stderr,
            result.stdout,
        )
        return ContainerResult(
            success=False,
            name=name,
            message=f"Failed to stop container '{name}'.",
            error=result.stderr or result.stdout,
        )
